МИНОБРНАУКИ РОССИИ
Федеральное государственное бюджетное
образовательное учреждение высшего образования
«САРАТОВСКИЙ НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ
ИМЕНИ Н.Г. ЧЕРНЫШЕВСКОГО»



Кафедра математической теории
упругости и биомеханики


Разработка сервиса знакомств

БАКАЛАВРСКАЯ РАБОТА

студента 4 курса 442 группы
направления 09.03.03 – Прикладная информатика
механико-математического факультета
Шишилина Даниила Игоревича

Научный руководитель
к.ю.н., доцент	                     	   				    Р.В. Амелин
                                                                  	          подпись, дата			  

Зав. кафедрой
д.ф.-м.н., профессор	            					    Л.Ю. Коссович
					          подпись, дата 			    












Саратов 2023


СОДЕРЖАНИЕ
ВВЕДЕНИЕ	3
1 Анализ предметной области	5
1.1 Описание предметной области	5
1.2 Обоснование необходимости создания сервиса знакомств	6
1.2.1 Сервис LovePlanet	7
1.2.2 Сервис Teamo	8
1.3 Итог сравнительного анализа сервисов знакомств	10
1.4 Постановка задачи	11
2 Проектирование сервиса	12
2.1 Определение архитектуры информационной системы	12
2.2 Структура базы данных	18
2.3 Использованные технологии	26
3 Реализация	33
3.1 Установка фреймворков и инструментов .Net Core	33
3.2 Работа с базой данных	34
3.3 Серверная реализация	35
3.4 Реализация и демонстрация пользовательского интерфейса	38
ЗАКЛЮЧЕНИЕ	43
СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ	44
Приложение А. Создание базы данных и таблиц	47
Приложение Б. Классы моделей базы данных	49
Приложение В. Код регистрации пользователя	51
Приложение Г. Код авторизации пользователя	52
Приложение Д. Использование модели данных в представлении	53







ВВЕДЕНИЕ
Современный образ жизни заставляет людей искать новые способы знакомства и общения. Один из таких способов - использование сервисов знакомств, которые позволяют людям находить партнеров для знакомства и создания отношений в онлайн-режиме. Сервисы знакомств - это веб-приложения, разработанные для удобного и быстрого поиска подходящих кандидатов для знакомства. 
Однако, несмотря на широкий выбор существующих сервисов знакомств, многие из них имеют ограниченный функционал и неудобный интерфейс, что может отталкивать пользователей. Некоторые сервисы знакомств не предоставляют возможность поиска по разным критериям, что затрудняет выбор подходящего партнера. Другие сервисы знакомств не предоставляют достаточно информации о кандидатах, что может приводить к неэффективности поиска и разочарованию в использовании таких сервисов.
Цель данной дипломной работы является разработка сервиса знакомств, который будет сочетать в себе удобный и понятный на интуитивном уровне интерфейс и достаточный функционал, позволяющий пользователям быстро и легко находить подходящего партнера для знакомства.
Для достижения цели работы были поставлены следующие задачи:
1.	Анализ рынка сервисов знакомств: провести исследование уже существующих сервисов знакомств, их особенностей, достоинств и недостатков, а также определить тенденции и перспективы развития данного рынка.
2.	Определение требований к разрабатываемому сервису. На этом этапе будет определен функционал, который должен быть реализован в сервисе, а также требования к интерфейсу и использованию сервиса.
3.	Разработка архитектуры и функционала сервиса: на этом этапе будет создана архитектура сервиса знакомств, включая проектирование базы данных, определение технологий и инструментов для разработки.
4.	Реализация сервиса: на этом этапе будет произведена непосредственная разработка сервиса знакомств на основе заданных требований и архитектуры. 
Решение этих задач поможет создать новый сервис с удобным интерфейсом и базовым функционалом для успешного поиска партнеров. Разработанный сервис позволит пользователям создавать свои профили, заполнять их необходимой информацией, изменять их, просматривать профили других пользователей, писать пользователям понравившихся анкет.






















1 Анализ предметной области
1.1 Описание предметной области
"Duo" - это современный сервис знакомств, специализирующийся на создании пар между людьми, которые ищут вторую половинку. Основная цель "Duo" - помочь пользователям найти партнёра, друга или стабильные отношения.
Сервис "Duo" предлагает базовый функционал, который позволяет пользователям находить партнеров по разным параметрам, например, по возрасту, послу и городу.
Основные направления деятельности "Duo" включают:
1.	Разработку и поддержку платформы для знакомств;
2.	Анализ и обработку данных пользователей для улучшения работы сервиса;
3.	Обеспечение безопасности и конфиденциальности данных пользователей;
4.	Оказание технической поддержки и консультаций пользователям.
При разработке сервиса придаётся особое внимание качеству кода, тестированию и оптимизации производительности. Активно применяются современные технологии, которые упрощают разработку и обеспечивают удобство для пользователей. Постоянное изучение новых технологий и лучших практик является неотъемлемой частью работы, чтобы постоянно улучшать сервис.
На рисунке 1 продемонстрирована организационная структура сервиса «Duo», на которой видно, что каждый аспект сервиса знакомств имеет свои департаменты, которые ответственны за определенные области работы [1]. Это помогает обеспечить более эффективное управление проектом, так как каждый департамент имеет свои задачи и ответственности, которые соответствуют общей стратегии сервиса.
 
Рисунок 1 - Организационная структура сервиса "Duo"
1.2 Обоснование необходимости создания сервиса знакомств
Современный образ жизни, особенно в больших городах, характеризуется высокой степенью занятости, частыми переездами, уменьшением времени на личную жизнь и нахождение на улице. Это может приводить к тому, что люди сталкиваются с трудностями в установлении новых знакомств и создании отношений. Для этого необходима разработка сервиса знакомств «Duo», который будет выполнять следующие задачи:
1.	Оптимизация процесса знакомства. С помощью сервиса знакомств можно значительно ускорить и упростить процесс знакомства с новыми людьми, особенно в условиях современного образа жизни, когда люди часто заняты работой, учебой и другими делами.
2.	Расширение круга знакомств. Сервис знакомств позволяет людям общаться и знакомиться с новыми людьми не только в своем городе или стране, но и за ее пределами, что расширяет круг общения и предоставляет новые возможности для личностного и культурного развития.
3.	Увеличение вероятности успешного знакомства. Сервис знакомств может предоставлять специальные алгоритмы подбора пар, основанные на общих интересах и предпочтениях, что повышает вероятность успешного знакомства и уменьшает количество неудачных попыток.
4.	Анализ данных и улучшение сервиса. Создание сервиса знакомств также предоставляет возможность для сбора и анализа данных о поведении пользователей, что может помочь улучшить качество и эффективность сервиса в будущем.
Для создания сервиса знакомств необходимо провести анализ рынка уже существующих сервисов знакомств и рассмотреть наиболее популярные из них. Это поможет понять, какие функции и возможности наиболее востребованы у пользователей и в каком направлении следует развиваться. Также, изучение конкурентов может помочь выявить их слабые стороны и преимущества, что позволит разработать уникальный продукт, который будет отличаться от конкурентов и привлекать новых пользователей.
	1.2.1 Сервис LovePlanet
LovePlanet.ru - это один из крупнейших русскоязычных сервисов знакомств, который был запущен в 2005 году компанией LovePlanet LLC. Сервис основан на платформе ASP.NET и использует язык программирования C# для разработки серверной части. Для хранения данных используется реляционная база данных Microsoft SQL Server [2].
Основной функционал сервиса включает в себя создание анкеты с указанием личных данных, фотографий, интересов и предпочтений в поиске партнера. LovePlanet.ru также предлагает систему поиска, которая позволяет находить анкеты с интересующими параметрами, а также функции чата, знакомств по геолокации, игровые развлечения и другие дополнительные сервисы.
Сервис LovePlanet.ru активно развивается и улучшается с тех пор, как был запущен. В настоящее время он имеет множество пользователей и считается одним из наиболее популярных сервисов знакомств в России и странах СНГ.
На рисунке 2 показан пользовательский интерфейс (UI) сервиса LovePlanet.
 
Рисунок 2 - Интерфейс сервиса LovePlanet
Несмотря на то, что LovePlanet.ru является одним из наиболее популярных сервисов знакомств в России, у него есть несколько недостатков:
1.	Наличие большого количества фейковых профилей на сайте. Это может привести к тому, что настоящие пользователи могут потратить много времени и энергии на поиск подходящего партнера.
2.	Интерфейс и дизайн сайта могут показаться немного устаревшими и неудобными для использования в сравнении с более современными сервисами знакомств.
3.	Некоторые функции сайта могут быть недоступны для пользователей, которые не оплатили подписку. Например, ограничен доступ к просмотру фотографий других пользователей и отправке сообщений.
1.2.2 Сервис Teamo
Teamo - это русскоязычный сервис онлайн-знакомств для серьезных отношений, который был создан в 2010 году. Основатели проекта - Александр Любимов и Дмитрий Картавцев. Сервис использует современные технологии и инструменты разработки, такие как Java, Spring Framework, React.js, и PostgreSQL [3]. 
Функционал сервиса позволяет пользователям создавать профили, искать других пользователей с помощью различных параметров (возраст, пол, город и т.д.), обмениваться сообщениями, оставлять отзывы о других пользователях, просматривать список просмотров своего профиля и многое другое. Кроме того, Teamo предоставляет поддержку менеджеров, которые помогают пользователям в поиске подходящих пар и организации встреч.
В отличие от многих других сервисов знакомств, Teamo ориентирован на людей, которые ищут серьезные отношения и готовы к браку. Сервис ставит перед собой цель помочь своим пользователям найти настоящую любовь, а не просто партнера для кратковременных отношений. На рисунке 3 показан пользовательский интерфейс (UI) сервиса Teamo.
 
Рисунок 3 - Интерфейс сервиса Teamo
Несмотря на то, что Teamo является популярным сервисом знакомств в России, у него также есть некоторые недостатки:
1.	Ограниченный бесплатный функционал. В отличие от некоторых конкурентов, такого как LovePlanet, у Teamo очень ограниченный бесплатный функционал. Например, пользователи не могут просматривать профили других пользователей без оплаты подписки. 
2.	Не всегда точные рекомендации. Алгоритмы поиска и подбора пар на Teamo не всегда могут предложить подходящего партнера для пользователя. Кроме того, даже если пользователь получил рекомендацию, профиль другого пользователя может быть устаревшим или недостаточно информативным.
3.	Ограниченная аудитория. Хотя Teamo является одним из крупнейших сервисов знакомств в России, его аудитория все ещё ограничена. Это может ограничить количество потенциальных партнеров для пользователей, особенно для тех, кто живет в малонаселенных или удаленных районах.
4.	Высокая стоимость подписки. Платная подписка на Teamo может быть довольно дорогой, особенно для длительных периодов времени. Это может ограничить доступность сервиса для пользователей, которые не могут позволить себе такие затраты.
5.	Отсутствие функции "подтверждения личности". Это может привести к тому, что некоторые пользователи могут создавать ложные профили или использовать фотографии, которые не соответствуют действительности.

1.3 Итог сравнительного анализа сервисов знакомств
Проведенный анализ двух рассмотренных сервисов знакомств показал, что оба сервиса имеют свои преимущества и недостатки.
Создание сервиса знакомств "Duo" может принести пользу пользователям, так как это даст им дополнительную возможность найти подходящего партнера или просто познакомиться с новыми людьми. Кроме того, сервис "Duo" будет использовать современные технологии и инструменты разработки, что может обеспечить более удобный и эффективный пользовательский опыт. Также, создание нового сервиса знакомств может стимулировать конкуренцию на рынке и привести к улучшению качества и функционала уже существующих сервисов.
Некоторые из популярных сервисов знакомств, таких как «Badoo», покинули российский рынок, оставив значительный пробел в предложении подобных услуг. Это создает потребность в разработке нового сервиса, который будет способствовать созданию новых знакомств и обеспечивать удобную платформу для общения между людьми. Более того, сервис "Duo" нацелен на импортозамещение, предлагая альтернативу иностранным сервисам, которые ранее доминировали на российском рынке знакомств.

1.4 Постановка задачи
Постановка задач для разработки сервиса знакомств «Duo» включает в себя следующие пункты:
1.	Выбор оптимальной платформы для создания сервиса, учитывая требования к производительности, масштабируемости и безопасности.
2.	Проектирование и создание базы данных для хранения информации о пользователях, их профилях и предпочтениях.
3.	Проектирование и разработка функционала сервиса.
4.	Проектирование и разработка базового веб-интерфейса сервиса, учитывая требования к удобству использования и функциональности.
После выполнения этих задач, результатом будет разработанный сервис знакомств "Duo". Он будет иметь веб-интерфейс, базу данных и базовый функционал, который позволит пользователям зарегистрироваться, создавать профили, внести основные сведения о себе, просматривать анкеты других пользователей с целью знакомства и возможно дальнейшего общения в реальной жизни, редактировать введённые ранее данные о себе, писать сообщения понравившемся пользователям.









2 Проектирование сервиса
2.1 Определение архитектуры информационной системы
Архитектуры информационных систем используются для организации, проектирования и построения сложных информационных систем. Они играют важную роль в разработке программного обеспечения, веб-приложений, баз данных и других информационных технологий [5].
Вот несколько основных причин, по которым архитектуры информационных систем являются важными:
1.	Определение структуры: архитектура информационной системы определяет ее структуру, компоненты и отношения между ними. 
2.	Разделение ответственности: архитектура информационной системы позволяет разделить ответственность между различными компонентами системы. 
3.	Масштабируемость и гибкость: хорошо спроектированная архитектура информационной системы обеспечивает масштабируемость и гибкость системы. 
4.	Управление сложностью: информационные системы могут быть очень сложными, с множеством компонентов, взаимодействующих между собой. 
5.	Безопасность: архитектура информационной системы играет важную роль в обеспечении безопасности системы.
Существует несколько типов архитектур информационных систем, которые могут быть использованы в разработке программного обеспечения. Рассмотрим наиболее распространенных архитектур информационных систем.
Монолитная архитектура информационной системы - это традиционный подход к разработке, при котором вся система представляет собой единое целое, в котором все компоненты и функциональность находятся внутри одного приложения или кодовой базы [6]. Схема монолитной архитектуры информационной системы представлена на рисунке 4.
 
Рисунок 4 - Монолитная архитектура информационной системы
Вот некоторые преимущества и недостатки монолитной архитектуры:
Преимущества монолитной архитектуры:
1.	Простота разработки: при использовании монолитной архитектуры разработка и развертывание системы может быть относительно простым, поскольку все компоненты находятся внутри одного приложения.
2.	Упрощенная локализация ошибок: при возникновении ошибки в монолитной системе отслеживание причины может быть проще, поскольку все компоненты находятся в одном месте.
3.	Лучшая производительность: В=внутри монолита взаимодействие между компонентами происходит напрямую, без использования сетевых вызовов или протоколов связи, что может быть более эффективным с точки зрения производительности.
Недостатки монолитной архитектуры:
1.	Сложность масштабирования: при росте размера системы монолитная архитектура может стать сложной для масштабирования. Если одна часть системы требует больше ресурсов, придется масштабировать всю систему вместе, даже если остальные компоненты не нуждаются в этом.
2.	Ограниченная гибкость: изменение или модификация отдельных компонентов в монолитной системе может быть сложным, поскольку они могут быть плотно связаны друг с другом. 
3.	Зависимость компонентов: при использовании монолитной архитектуры все компоненты системы зависят друг от друга. 
4.	Усложнение сопровождения: сопровождение и развитие монолитной системы могут быть сложными, особенно при наличии большого количества кода и компонентов. 
Клиент-серверная архитектура информационной системы (Client-Server Architecture) является распространенным подходом к построению и развертыванию систем, в котором функциональность разделена между клиентскими и серверными компонентами. В такой архитектуре клиенты запрашивают данные или услуги у серверов, которые обрабатывают запросы и отвечают на них [7]. Схема клиент-серверной архитектуры информационной системы представлена на рисунке 5. 
 
Рисунок 5 – Схема клиент-серверной архитектуры информационной системы
Вот некоторые преимущества и недостатки клиент-серверной архитектуры:
Преимущества клиент-серверной архитектуры:
1.	Распределение обязанностей: Клиенты и серверы выполняют различные функции, что позволяет разделить ответственность между ними. Клиенты обеспечивают пользовательский интерфейс и взаимодействуют с пользователем, в то время как серверы обрабатывают бизнес-логику, хранят данные и предоставляют услуги.
2.	Масштабируемость: В клиент-серверной архитектуре можно масштабировать серверные компоненты отдельно от клиентов. Это означает, что можно добавлять или увеличивать серверы для обработки большего количества запросов или для увеличения производительности системы. 
3.	Централизованное управление данными: Серверы в клиент-серверной архитектуре обычно являются источником данных. 
4.	Улучшенная безопасность: Клиент-серверная архитектура позволяет реализовать механизмы защиты данных и контроля доступа на уровне серверов. 
Недостатки клиент-серверной архитектуры:
1.	Единая точка отказа: Если серверная часть системы перестает работать, это может привести к недоступности всей системы. В случае отказа сервера клиенты не смогут получить доступ к необходимым данным или услугам.
2.	Зависимость от сети: Клиент-серверная архитектура требует сетевого взаимодействия между клиентами и серверами. Это означает, что надежность и производительность системы могут зависеть от надежности и пропускной способности сети. 
3.	Сложность сопровождения: Клиент-серверная архитектура может быть более сложной в сопровождении и развертывании по сравнению с монолитной архитектурой. 
4.	Ограниченная масштабируемость клиентской части: Если количество клиентов растет, это может потребовать дополнительных ресурсов на стороне клиента. 
Многоуровневая архитектура информационной системы (Multitier Architecture) — это подход к разработке и построению системы, в котором функциональность разделена на несколько уровней (слоев), каждый из которых выполняет определенные задачи. Каждый уровень представляет собой логически независимую компоненту, которая взаимодействует с другими уровнями по определенным правилам [8]. Схема многоуровневой архитектуры информационной системы представлен на рисунке 6.
 
Рисунок 6 - Многоуровневая архитектура информационной системы
Некоторые преимущества и недостатки многоуровневой архитектуры:
Преимущества многоуровневой архитектуры:
1.	Разделение ответственности: Многоуровневая архитектура позволяет разделить функциональность и ответственность между различными уровнями системы. 
2.	Гибкость и масштабируемость: Каждый уровень в многоуровневой архитектуре может быть масштабирован отдельно, в зависимости от требований системы. 
3.	Улучшенная отказоустойчивость: При наличии многоуровневой архитектуры отказ одного уровня не обязательно приведет к полной неработоспособности системы. 
4.	Легкость внесения изменений: Каждый уровень системы может быть модифицирован или заменен независимо от других уровней. Недостатки многоуровневой архитектуры:
1.	Сложность разработки: Многоуровневая архитектура требует более сложной разработки и взаимодействия между уровнями. 
2.	Накладные расходы на коммуникацию: Использование многоуровневой архитектуры включает в себя взаимодействие между различными уровнями по сети или другими способами передачи данных
3.	Усложненное управление состоянием: В многоуровневой архитектуре у каждого уровня может быть свое состояние или контекст, которые необходимо согласовывать и управлять.
Микросервисная архитектура информационной системы (Microservices Architecture) - это подход к разработке и построению системы, в котором функциональность разбита на небольшие и независимые сервисы, которые взаимодействуют между собой через легковесные протоколы коммуникации. Каждый сервис представляет собой отдельно развертываемую и масштабируемую компоненту, обычно собираемую вокруг конкретной бизнес-задачи [9]. Схема микросервисной архитектуры информационной системы представлен на рисунке 7.
 
Рисунок 7 - Микросервисная архитектура информационной системы
Вот некоторые преимущества и недостатки микросервисной архитектуры:
Преимущества микросервисной архитектуры:
1.	Масштабируемость и гибкость: Каждый сервис может быть масштабирован отдельно, в зависимости от требований нагрузки. Это позволяет горизонтально масштабировать только необходимые компоненты системы, обеспечивая оптимальное использование ресурсов. 
2.	Распределенная разработка: Микросервисная архитектура позволяет разработчикам работать над различными сервисами параллельно.
3.	Независимость технологий: Каждый сервис может быть реализован с использованием технологий и языков программирования, наиболее подходящих для конкретной задачи. 
4.	Легкость внесения изменений: Благодаря модульной структуре и независимости сервисов, внесение изменений становится более простым. 
Недостатки микросервисной архитектуры:
1.	Сложность управления: Микросервисная архитектура требует управления большим количеством сервисов. Координирование, мониторинг и отслеживание состояния всех сервисов может быть сложной задачей. 
2.	Усложненное тестирование: При наличии множества независимых сервисов, тестирование системы в целом может стать более сложным. 
3.	Коммуникационные задержки: Взаимодействие между сервисами осуществляется по сети, что может привести к задержкам в передаче данных. 
4.	Увеличенная сложность отладки: Когда система состоит из множества сервисов, отладка проблем и выявление ошибок может быть сложной задачей. 
Для разработки сервиса знакомств "Duo" многоуровневая архитектура является подходящим выбором. В таком сервисе важно разделять бизнес-логику от пользовательского интерфейса, чтобы обеспечить гибкость, масштабируемость и легкость внесения изменений. Разделение бизнес-логики от представлений в рамках многоуровневой архитектуры позволит упростить разработку и сопровождение системы "Duo". Каждый уровень будет отвечать за свои задачи и иметь свою специфику.

2.2 Структура базы данных
База данных (БД) - это организованная коллекция данных, которая обычно хранится и управляется с помощью компьютерной системы. БД позволяют хранить и обрабатывать большие объемы информации, обеспечивая удобный и быстрый доступ к данным. В БД данные организованы в виде таблиц, связанных друг с другом по определенным правилам и отношениям.
Реляционная база данных - это тип базы данных, в которой данные хранятся в виде таблиц, состоящих из строк и столбцов. Отношения между таблицами определяются ключами и связями. Реляционная модель баз данных была предложена в 1970 году Эдгардом Коддом, который тогда работал в IBM [10]. 
Основной принцип реляционной модели заключается в том, что данные хранятся в нормализованной форме, что обеспечивает целостность и согласованность данных. Реляционные базы данных предоставляют мощный и эффективный инструмент для управления данными, который позволяет производить операции, такие как добавление, обновление, удаление и поиск данных.
Основные преимущества реляционных баз данных включают в себя легкость использования, простоту и гибкость проектирования, масштабируемость и надежность. Они также обеспечивают высокий уровень безопасности и защиты данных.
В реляционной базе данных информация хранится в отношениях между таблицами. Эти отношения могут быть установлены при помощи первичных ключей, внешних ключей и индексов.
Первичный ключ - это уникальный идентификатор для каждой записи в таблице, используется для идентификации каждой строки в таблице. Внешний ключ - это поле в одной таблице, которое ссылается на первичный ключ в другой таблице. Индекс позволяет быстро находить строки, удовлетворяющие определенным критериям.
	Реляционная система управления БД должна соответствовать требованию ACID:
•	Атомарность (Atomicity) - гарантирует, что операция либо выполнится полностью, либо не выполнится вовсе. Если при выполнении операции происходит ошибка или прерывание, то база данных должна вернуться в исходное состояние.
•	Согласованность (Consistency) - гарантирует, что база данных всегда будет находиться в согласованном состоянии. Это означает, что все данные в базе данных должны соответствовать определенным правилам, ограничениям и условиям, заданным в структуре базы данных.
•	Изолированность (Isolation) - гарантирует, что каждая транзакция будет выполнена в изолированной среде и не повлияет на другие транзакции, выполняющиеся в то же время. Это означает, что транзакции должны быть выполнены в определенном порядке и не должны взаимодействовать друг с другом.
•	Надежность (Durability) - гарантирует, что после выполнения транзакции ее результаты сохранятся в базе данных навсегда, даже если произойдет сбой в системе. Это достигается путем сохранения данных на диске или другом надежном носителе.
Перейдём к проектированию БД, которое, как правило, происходит на двух уровнях, логическом и физическом, что является важным этапом разработки информационной системы [11]. Логическое проектирование описывает структуру и связи между данными, а физическое проектирование определяет, как эта структура будет реализована в базе данных.
В процессе логического проектирования базы данных необходимо определить, какие сущности будут храниться в базе данных, как они связаны друг с другом и какие атрибуты должны быть у каждой сущности. Для этого часто используется ER-моделирование (Entity-Relationship), которое позволяет описать сущности, их атрибуты и связи между ними. В результате этого процесса мы получаем ER-диаграмму, которая представляет структуру базы данных. Опишем ER-диаграмму для нашего сервиса, как показано на рисунке 8
 
Рисунок 8 - ER модель базы данных
	Данная схема таблиц в базе данных позволит хранить ориентированные графы [12]. База данных состоит из 4 таблиц: «Users», «Guests», «Likes», «Messages». Рассмотрим атрибуты каждой таблицы.
	Таблица «Users» содержит 15 атрибутов:
	Первичный ключ UserId (идентификатор пользователя);
	Username (логин пользователя);
	Password (пароль пользователя);
	FirstName (имя пользователя);
	LasName (фамилия пользователя);
	Age (возраст пользователя);
	Heigth (рост пользователя);
	Weigth (вес пользователя);
	City (город пользователя);
	PhotoUrl (ссылка на фотографию пользователя);
	Zodiac (знак зодиака пользователя);
	InterestType (интерес пользователя);
	InterestDescription (описание интереса пользователя);
	Email (вес пользователя);
	Gender (пол пользователя).
Таблица «Likes» содержит 3 атрибута:
	Первичный ключ LikeId (идентификатор симпатии);
	Внешний ключ SenderId (Отсылает к таблице «Users» и позволяет определить кто поставил симпатию на анкете);
	Внешний ключ RecipientId (Отсылает к таблице «Users» и позволяет определить кому была поставлена симпатия).
Таблица «Guests» содержит 3 атрибута:
	Первичный ключ GuestId (идентификатор гостя);
	Внешний ключ SenderGId (Отсылает к таблице «Users» и позволяет определить кто заходил в профиль пользователя);
	Внешний ключ RecipientGId (Отсылает к таблице «Users» и позволяет определить к какому пользователю заходили в профиль).
Таблица «Messages» содержит 5 атрибутов:
	Первичный ключ MessageId (идентификатор сообщения);
	Внешний ключ SenderId (Отсылает к таблице «Users» и позволяет определить кто является отправителем сообщения);
	Внешний ключ RecipientId (Отсылает к таблице «Users» и позволяет определить кто является получателем сообщения);
	Content (содержание сообщения);
	Timestamp (показывает время в которое было отправлено сообщение)
После завершения логического проектирования необходимо перейти к физическому проектированию. Оно включает в себя определение типов данных для каждого атрибута, определение первичных и внешних ключей, индексов и других настроек базы данных. Физическое проектирование базы данных должно учитывать требования к производительности и надежности базы данных [11].
Важно учитывать требования к базе данных, чтобы она соответствовала принципам ACID (Atomicity, Consistency, Isolation, Durability). Эти принципы гарантируют, что транзакции в базе данных будут выполняться надежно и безопасно, что в свою очередь важно для правильной работы информационной системы. Исходя из вышесказанного выбор системы управления базами данных упал на MSSQL. MS SQL Server (Microsoft SQL Server) - это реляционная система управления базами данных (СУБД), разработанная корпорацией Microsoft. Она использует язык SQL (Structured Query Language) для управления данными в базе данных.
SQL Server (Structured Query Language Server) - это реляционная система управления базами данных (СУБД), разработанная и выпускаемая компанией Microsoft. Она предназначена для хранения, организации и управления данными, а также обеспечивает доступ к данным через стандартный язык запросов SQL (Structured Query Language) [13].
MS SQL Server является одной из наиболее популярных СУБД на рынке и широко используется в корпоративной среде. Он предоставляет множество функций, таких как масштабируемость, высокую производительность, поддержку транзакций и защиту данных.
Microsoft SQL Server имеет несколько версий и редакций, включая SQL Server Express, SQL Server Standard Edition, SQL Server Enterprise Edition и другие. Каждая версия предлагает разные функциональные возможности и масштабируемость, чтобы удовлетворить различные потребности предприятий и разработчиков.
Преимущества MS SQL Server:
1. Надежность и стабильность: MS SQL Server известен своей высокой надежностью и стабильностью. Он способен обрабатывать большие объемы данных и обеспечивать постоянную доступность к базе данных даже при высоких нагрузках.
2. Широкий функционал: MS SQL Server предлагает обширный набор функций и возможностей для управления базами данных. Он поддерживает транзакции, хранимые процедуры, триггеры, репликацию данных, аналитические функции и многое другое. Это делает его мощным инструментом для различных приложений и сценариев.
3. Интеграция с другими продуктами Microsoft: MS SQL Server хорошо интегрируется с другими продуктами Microsoft, такими как Windows Server, .NET Framework и Microsoft Azure. Это облегчает разработку и развертывание приложений, основанных на экосистеме Microsoft.
4. Масштабируемость: MS SQL Server предлагает возможности масштабирования, позволяющие увеличивать производительность и емкость базы данных с ростом бизнес-потребностей. Он поддерживает репликацию, кластеризацию и разделение данных, что делает его гибким решением для предприятий любого размера.
Недостатки MS SQL Server:
1. Лицензирование и стоимость: MS SQL Server является коммерческим продуктом, что означает наличие лицензионных ограничений и определенных расходов. Для крупных предприятий или проектов с большим объемом данных, стоимость лицензий может быть значительной.
2. Зависимость от экосистемы Microsoft: В то время как интеграция с другими продуктами Microsoft является преимуществом, она также создает зависимость от этой экосистемы. Использование MS SQL Server может быть менее удобным, если вы разрабатываете или работаете в среде, где предпочитаются другие технологии или платформы.
3. Ограничения в плане масштабирования: В некоторых случаях масштабирование MS SQL Server может стать сложной задачей. Хотя он предлагает возможности масштабирования, в некоторых сценариях с высокой нагрузкой или масштабируемостью требуется более специализированное решение.
4. Ограниченная поддержка некоторых функций: Некоторые новые и экспериментальные функции и технологии, доступные в других СУБД, могут быть ограничены или отсутствовать в MS SQL Server. Это может быть недостатком для определенных проектов, которым требуются специфические возможности.
Выбор MSSQL для разработки сервиса знакомств обусловлен его функциональностью, интеграцией с .NET и Entity Framework Core, надежностью, производительностью, а также доступностью поддержки и ресурсов для разработчиков. Схема взаимодействия базы данных SqlServer, системы управления базами данных MSSQL, языка программирования C# и платформы продемонстрирована на рисунке 9.
 
Рисунок 9 - Взаимодействие компонентов с СУБД
Составим физическую модель базы данных с учётом выбора MSSQL в качестве СУБД. На рисунке 10 продемонстрирована физическая модель базы данных.
 
Рисунок 10 - Физическая модель базы данных
Для каждого атрибута, содержащего целое число, был выбран тип данных «int», для тех, у кого могут быть значения с плавающей точкой (с дробной частью) был назначен тип данных «float». Все значения, которые имеют текстовое содержание получили тип данных «varchar» с соответствующим ограничением по количеству символов. Для хранения изображений был выбран тип данных varchar(255) так как это позволит правильно хранить ссылку на изображение, расположенное в файлах проекта. Также для каждого первичного ключа было задано условие «Identity(1,1)», что означает, что с каждой новой записью идентификатор будет автоматически заполняться с 1 с шагом 1 по возрастанию. Полный код запросов создания базы данных и таблиц описан в приложении А.

2.3 Использованные технологии
	Выбор платформы разработки является важным шагом, поскольку влияет на производительность, гибкость, поддержку и расширяемость разрабатываемого сервиса.
.NET Core - это кроссплатформенная, открытая, высокопроизводительная, модульная и облегченная версия платформы .NET [14].
Основными преимуществами .NET Core являются:
•	Кроссплатформенность: .NET Core может работать на различных операционных системах, таких как Windows, Linux и macOS.
•	Высокая производительность: .NET Core оптимизирован для работы в высоконагруженных сценариях и имеет быструю JIT-компиляцию.
•	Облегченность: .NET Core имеет небольшой размер и быстрое время запуска.
•	Модульность: .NET Core имеет модульную архитектуру, которая позволяет использовать только те компоненты, которые необходимы для приложения.
•	Открытость: .NET Core является открытым исходным кодом и имеет большое сообщество разработчиков.
Недостатки .NET Core:
•	Ограниченная поддержка сторонних библиотек и фреймворков по сравнению с платформой .NET Framework.
•	Некоторые старые API-интерфейсы, которые присутствуют в платформе .NET Framework, могут отсутствовать в .NET Core.
.NET Core была выбрана для создания сервиса знакомств, так как она является кроссплатформенной, имеет высокую производительность, облегченность и модульность, что позволяет разрабатывать и запускать веб-приложения на различных операционных системах с высокой производительностью. Кроме того, использование .NET Core совместно с Entity Framework Core позволяет быстро и просто взаимодействовать с базой данных и упрощает процесс разработки веб-приложения.
	 Entity Framework Core (EF Core) - это кросс-платформенный ORM (Object-Relational Mapping) фреймворк, который позволяет разработчикам работать с данными в СУБД через объектно-ориентированный подход, не задумываясь о деталях взаимодействия с БД [15]. EF Core был создан как современная, более легковесная и кросс-платформенная версия Entity Framework, которая может работать в различных окружениях, таких как Windows, Linux и macOS.
Некоторые преимущества EF Core:
•	Упрощенный доступ к данным: разработчику не нужно заботиться о низкоуровневых деталях работы с БД, таких как создание SQL-запросов, настройка соединений и т.д. Вместо этого, он может работать с данными в виде объектов, что упрощает и ускоряет процесс разработки.
•	Кросс-платформенность: EF Core поддерживает работу с различными СУБД, включая SQL Server, MySQL, PostgreSQL и другие, и может быть использован в различных операционных системах.
•	LINQ-запросы: EF Core поддерживает использование LINQ-запросов, что позволяет упростить поиск и выборку данных из БД.
•	Поддержка миграций: EF Core позволяет управлять изменениями в структуре БД с помощью миграций, что упрощает процесс развития приложения и обновления БД.
Причины использования EF Core для разработки сервиса знакомств могут быть следующими:
•	EF Core позволяет работать с данными через объектно-ориентированный подход, что упрощает процесс разработки и позволяет ускорить время разработки.
•	EF Core поддерживает миграции, что упрощает процесс изменения структуры БД во время разработки и обновления приложения.
•	Кросс-платформенность EF Core позволяет развернуть сервис знакомств на различных платформах и операционных системах.
•	EF Core обладает хорошей производительностью и поддерживает кэширование запросов, что может ускорить работу приложения.
•	EF Core интегрируется с ASP.NET Core, что облегчает разработку веб-приложений.

В EF Core существуют два подхода к разработке баз данных: CodeFirst и BaseFirst.
Подход CodeFirst предлагает создавать модели данных и маппинги в коде, а затем позволяет EF Core автоматически генерировать схему базы данных на основе этих моделей [16]. Ниже приведены преимущества и недостатки подхода CodeFirst:
Преимущества:
1.	Простота и быстрота разработки: CodeFirst позволяет быстро начать разработку, так как требуется всего лишь определить модели данных и их отношения в коде.
2.	Гибкость: Возможность легко изменять структуру базы данных, добавлять или изменять поля в моделях данных без необходимости вручную вносить изменения в схему базы данных.
3.	Удобство тестирования: Модели данных можно легко тестировать, так как они независимы от реальной базы данных.
Недостатки:
1.	Зависимость от кода: В случае изменений структуры базы данных требуется внесение соответствующих изменений в код моделей данных. Это может привести к неудобству и потенциальным ошибкам при масштабировании или изменении базы данных.
2.	Ограничения при работе с существующей базой данных: CodeFirst может оказаться неудобным, если вы работаете с уже существующей базой данных и хотите сгенерировать модели данных на основе существующей схемы.
Подход BaseFirst предполагает создание схемы базы данных с использованием средств визуального проектирования (например, в Microsoft SQL Server Management Studio) и затем генерацию моделей данных на основе этой схемы [17]. Ниже приведены преимущества подхода BaseFirst:
Преимущества:
1.	Более прямое отражение существующей базы данных: Подход BaseFirst позволяет легко создать модели данных, которые соответствуют существующей базе данных. Это особенно полезно, если вы уже имеете готовую схему базы данных и хотите быстро создать соответствующие модели.
Несмотря на преимущества BaseFirst, он имеет ряд недостатков:
1.	Ограничения в гибкости: В случае изменения структуры базы данных требуется вручную вносить соответствующие изменения в схему и модели данных. Это может затруднить масштабирование и изменение базы данных в долгосрочной перспективе.
2.	Усложнение процесса разработки: BaseFirst требует начального этапа создания схемы базы данных отдельно от кода, что может увеличить сложность разработки и координацию с командой разработчиков.
Преимущество подхода BaseFirst перед CodeFirst заключается в более прямом отражении существующей базы данных в моделях данных. Вот некоторые преимущества BaseFirst по сравнению с CodeFirst:
1.	Быстрое создание моделей данных: BaseFirst позволяет быстро создавать модели данных на основе существующей схемы базы данных. Вы можете использовать инструменты визуального проектирования баз данных, такие как Microsoft SQL Server Management Studio, чтобы визуально создать структуру базы данных и затем сгенерировать модели данных на ее основе. Это упрощает и ускоряет процесс создания моделей.
2.	Отражение изменений в базе данных: Если вам потребуется внести изменения в схему базы данных, такие как добавление новых таблиц или полей, BaseFirst позволяет обновить модели данных, отражая эти изменения автоматически. Вам не нужно вносить изменения в код моделей вручную, как это может потребоваться в подходе CodeFirst. Это упрощает обновление моделей данных и поддержание их соответствия с базой данных.
3.	Точное отражение структуры базы данных: BaseFirst обеспечивает более точное отражение структуры базы данных в моделях данных. Поскольку схема базы данных уже определена, модели данных будут полностью соответствовать этой схеме. Это особенно полезно в случае существующих баз данных, где структура уже определена и важно сохранить ее целостность и соответствие.
4.	Удобство работы с существующими базами данных: Если у вас уже есть существующая база данных, BaseFirst может быть более предпочтительным подходом, поскольку он позволяет легко создать соответствующие модели данных, отражающие существующую схему. Это может сэкономить время и усилия, которые потребовались бы для вручную создания моделей данных в подходе CodeFirst.
В целом, преимущество BaseFirst заключается в возможности быстрого и точного отражения существующей базы данных в моделях данных. Это позволяет упростить и ускорить разработку, особенно при работе с существующими базами данных.
Для разработки на платформе .Net Core будет использоваться IDE (Integrated Development Environment) Visual Studio, а также язык программирования C#. Visual Studio - это интегрированная среда разработки, созданная компанией Microsoft, которая позволяет разрабатывать приложения на .Net, включая .Net Core [18]. Она предоставляет различные инструменты для создания, отладки и развертывания приложений, а также интегрируется с различными средствами контроля версий. Visual Studio имеет множество функций и инструментов, что делает ее очень удобной и мощной средой разработки.
В рамках проекта сервис знакомств «Duo» будут использованы следующие инструменты для разработки клиентской части:
	HTML (HyperText Markup Language) - это язык разметки, используемый для создания структуры и представления веб-страниц. Он состоит из набора тегов (элементов), которые определяют структуру и содержимое страницы [19]. 
	CSS (Cascading Style Sheets) - это язык стилей, используемый для оформления и визуального оформления веб-страниц. Он определяет внешний вид и расположение элементов HTML на странице [19].
	JavaScript - это высокоуровневый интерпретируемый язык программирования, который широко используется для разработки интерактивных веб-страниц. Он позволяет добавлять динамическое поведение к HTML-элементам, управлять событиями, выполнять асинхронные запросы к серверу, создавать анимацию и многое другое [20].
Эти технологии являются основными для создания веб-страниц и веб-приложений, и будут использоваться для создания клиентской части сервиса знакомств.
















3 Реализация
3.1	Установка фреймворков и инструментов .Net Core
В процессе разработки будет постоянное обращение к базе данных для добавления, хранения, обработки и получения данных.  Поэтому для удобного взаимодействия с базой данных будет использован пакет «Microsoft.EntityFrameworkCore», который предоставит основные классы и методы для определения моделей данных, выполнение запросов и управление базой данных. Он позволяет работать с данными, используя объекты и LINQ-запросы, вместо прямой работы с SQL-запросами. Это упрощает кодирование и повышает читаемость кода, делая процесс работы с базой данных более интуитивным. А для произведения операций конкретно в базе данных он автоматически генерирует SQL-запросы и выполняет операции CRUD, что упрощает создание, чтение, обновление и удаление данных.
Для самой базы данных требуется пакет «Microsoft.EntityFrameworkCore.SqlServer». Он содержит провайдер данных SQL Server для EF Core. Он предоставляет драйвер и интеграцию для взаимодействия с базой данных Microsoft SQL Server с использованием EF Core. Это позволяет выполнять операции CRUD, создавать запросы и обновлять схему базы данных на сервере SQL Server.
	Помимо этого, необходимы инструменты миграций. «Microsoft.EntityFrameworkCore.SqlServer.Design» - предоставляет инструменты, необходимые для разработки и взаимодействия с базой данных SQL Server при использовании EF Core. В частности, он предоставляет инструменты миграций, которые позволяют обновлять схему базы данных при изменении модели данных. «Microsoft.EntityFrameworkCore.SqlServer.Tools» - включает в себя команды инструмента dotnet-ef, которые позволяют выполнять миграции базы данных, создавать модель данных, генерировать SQL-скрипты. Это облегчает разработку и управление базой данных SQL Server в рамках проекта на платформе .NET Core.
Чтобы установить эти пакеты в проекте, необходимо выполнить команду «dotnet add package» в командной строке. Например, для установки «Microsoft.EntityFrameworkCore.SqlServer» применяется команда «dotnet add package Microsoft.EntityFrameworkCore.SqlServer».
Установка фреймворков и инструментов .NET Core, включая Entity Framework Core и связанные с ним пакеты, обеспечивает удобство и простоту работы с базой данных, предоставляет ORM-функциональность, абстракцию базы данных и инструменты миграций. Это помогает ускорить процесс разработки, повысить производительность сервиса.

3.2	Работа с базой данных
База данных уже создана, поэтому используется метод «Database First». Для подключения необходимо открыть консоль диспетчера пакетов. Выполнить команду «Scaffold-DbContext», указав строку подключения к существующей базе данных, провайдер базы данных (в данном случае «Microsoft.EntityFrameworkCore.SqlServer») и имя проекта DAL. Команда будет выглядеть следующим образом.
Листинг 1 – Команда для подключения к базе данных
Scaffold-DbContext "Server=POKEMON\SQLEXPRESS;Database=Krop;TrustServerCertificate=True;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -project DAL

«TrustServerCertificate=True» - указывает, что клиент доверяет сертификату сервера SQL. Он используется для установки доверительного отношения к серверному сертификату SSL/TLS. Когда «TrustServerCertificate=True», клиент доверяет серверному сертификату без проверки его подлинности.
«Trusted_Connection=True» - указывает, что подключение к базе данных должно использовать доверительное подключение. Когда Trusted_Connection=True, аутентификация происходит с использованием Windows-аккаунта текущего пользователя. Это означает, что приложение будет использовать учетные данные текущего пользователя для аутентификации при подключении к базе данных.
После подключения к базе данных произойдёт генерация классов моделей данных. На основе анализа существующей базы данных, «Entity Framework Core» сгенерирует классы моделей данных. Эти классы будут представлять таблицы и столбцы базы данных в виде объектов, которые можно использовать в приложении для доступа к данным. Получившиеся классы моделей продемонстрированы в приложении Б. 

3.3	Серверная реализация
Необходимые библиотеки уже установлены, классы моделей данных имеются. Начнём с реализации регистрации пользователя, который, в свою очередь, вводит логин и пароль. Код регистрация или обновления пользователя продемонстрирован в приложении В.
Объявляем метод «Registration» с атрибутом [HttpPost], который обрабатывает POST-запросы на регистрацию пользователя. Проверяем, что введенные пароли (password и password2) совпадают и значение login не является пустым. Создаём новый экземпляр класса «Entity.User» и заполняем его свойства значениями из параметров метода. Вызываем метод «Authenticate», который выполняет аутентификацию пользователя. Затем вызываем метод «BL.UserBL.Registrations» с передачей созданного экземпляра пользователя для его регистрации. Если все прошло успешно, выполняем перенаправление на действие "Registration2" контроллера "Home". Если пароли не совпадают или значение login равно null, возвращается представление «View» [21]. 
	Рассмотрим подробнее метод «Authenticate». Он принимает имя пользователя в качестве параметра, создает утверждение о имени пользователя и устанавливает аутентификационные куки для пользователя. После успешной аутентификации, информация об аутентифицированном пользователе будет доступна в различных частях приложения, и «Claims» могут быть использованы для проверки прав доступа или получения дополнительной информации о пользователе.
	После успешной регистрации пользователю предоставляется возможность заполнить данные в разделе «Общие сведения». На этом этапе обратим внимание на добавление пользователем фотографии профиля. В базе данных указано поле «PhotoUrl», которое хранит путь для нахождения изображения. 
Листинг 2 – Добавление изображения в проект
string uploadsFolder = Path.Combine(_webHostEnvironment.WebRootPath, "css");
string fileName = Path.GetFileName(photoFile.FileName);
string uniqueFileName = Guid.NewGuid().ToString() + "_" + fileName;
string filePath = Path.Combine(uploadsFolder, uniqueFileName);
using (var fileStream = new FileStream(filePath, FileMode.Create)){
await photoFile.CopyToAsync(fileStream);}
string photoUrl = $"/css/{uniqueFileName}";
DAL.Photo p = new DAL.Photo();
p.PhotoUrl = photoUrl;
p.UserId = pl.UserId;
BL.PhotoBL.Registrations2(p);

	Рассмотрим по этапам работу данного метода:
1.	uploadsFolder» представляет путь к папке, где будут храниться загруженные файлы, в данном случае, объединяются пути к корню веб-приложения и подпапки «css».
2.	«filename» содержит оригинальное название изображения.
3.	«uniqueFileName» хранит в себе сгенерированный новый уникальный идентификатор в формате GUID, который добавлен к оригинальному названию фотографии.
4.	«filePath» собирает путь к файлу, происходит объединение пути к файлу и его названием, чтобы получить полный путь к месту сохранения файла.
5.	Далее происходит запись файла по указанному пути и сохранение в переменной полного пути к сохранённому изображению.
На рисунке 11 показана структура каталога «wwwroot/css», куда сохраняются файлы, добавленные пользователем.
 
Рисунок 11 - Структура каталога wwwroot/css
	Предположим, пользователь уже зарегистрирован и для доступа к сайту ему необходимо авторизоваться. Для этого применялся стандартный метод проверки пользователя. Рассмотрим код авторизации пользователя, продемонстрированном в приложении Г, подробнее. 
Метод «Index» без параметров является [HTTP] GET методом, который выполняется при первоначальной загрузке страницы. Внутри этого метода происходит проверка «User.Identity.IsAuthenticated», которая определяет, аутентифицирован ли пользователь. Если пользователь уже аутентифицирован, то происходит перенаправление на действие "Profile" контроллера "Home" при помощи метода «RedirectToAction».
Метод «Index» с параметрами является [HTTP] POST методом, который выполняется при отправке формы для авторизации. Внутри этого метода создается объект «Entity.User» с указанными значениями login и password.
Затем происходит вызов метода «BL.UserBL.Autorisations(player)», который выполняет проверку правильности аутентификационных данных пользователя [22]. Если аутентификация прошла успешно, то вызывается метод «Authenticate», о котором говорилось ранее, для аутентификации пользователя, и происходит перенаправление на действие "Profile" контроллера "Home" при помощи метода «RedirectToAction».
Если аутентификация не удалась или введены неверные данные, то возвращается то же представление "Index", что позволяет показать ошибку пользователю.

3.4	Реализация и демонстрация пользовательского интерфейса
Для взаимодействия баз данных с модулем представления в сервисе знакомств "Duo" используется архитектурный паттерн MVC (Model-View-Controller).  MVC (Model-View-Controller) - это паттерн проектирования, который разделяет приложение на три основных компонента: модель, представление и контроллер [23]. Схема паттерна MVC показана на рисунке 12.
•	Модель (Model): Модель представляет собой компонент, отвечающий за бизнес-логику и доступ к данным. В контексте "Duo" модель будет включать компоненты, связанные с базой данных, такие как сущности пользователей, профили, совместимости и другие данные, необходимые для функционирования сервиса. Модель обеспечивает методы для получения, обновления и сохранения данных, а также реализует правила и логику, связанные с бизнес-процессами.
•	Представление (View): Представление отвечает за отображение данных пользовательского интерфейса и взаимодействие с пользователем. В контексте "Duo" представление будет включать компоненты, отображающие профили пользователей, формы регистрации и аутентификации, страницы поиска и другие элементы пользовательского интерфейса. Представление получает необходимые данные из модели и отображает их пользователю, а также перенаправляет пользовательские действия контроллеру.
•	Контроллер (Controller): Контроллер является посредником между моделью и представлением. Он обрабатывает пользовательские запросы, получает данные из модели, инициирует необходимые операции и обновляет представление. В случае сервиса "Duo" контроллер будет обрабатывать действия пользователей, такие как регистрация, вход в систему, поиск совместимых пар и другие взаимодействия. Контроллер также обновляет модель в соответствии с пользовательскими действиями.
 
Рисунок 12 - Схема паттерна MVC
Для работы с пользовательским интерфейсом будут использованы файлы с расширением «cshtml». Данные файлы (Razor View) являются частью ASP.NET Core MVC и используются для создания пользовательского интерфейса (UI) веб-приложений. Удобство их использования заключается в возможности использования серверного кода, например, С# внутри представления, о чём позже будет рассказано подробнее [24]. Использование файлов CSHTML упрощает разработку пользовательского интерфейса, обеспечивает чистоту кода, повышает его читаемость и позволяет разделить логику и представление приложения. Это приводит к более поддерживаемому и гибкому коду, что является значимым преимуществом при разработке веб-приложений. Пример использования файла с расширение «cshtml» для вывода анкет пользователей представлен в приложении Д.
Перед началом использования сервисом пользователь должен в нём зарегистрироваться. Окно регистрации продемонстрировано на рисунке 13. Пользователю необходимо ввести свой логин, пароль, почту, а также имя и фамилию. 
После заполнения необходимых данных при регистрации, необходимо заполнить такие поля, как возраст, вес, рост, город проживания, пол, знак зодиака, увлечение и описать поподробнее выбранный интерес. 
	После успешного заполнения формы данных о себе, пользователь перенаправляется в раздел «Мой профиль», где видит всю информацию о себе, которую вводил ранее. Если какая-то информация устарела, например, смена места проживания, то можно нажать на кнопку «Редактировать профиль» и изменить соответствующую информацию. Окно профиля показано на рисунке 14.
 
Рисунок 14 - Профиль пользователя
Далее есть возможность перейти в раздел просмотра анкет, где буду показаны все анкеты пользователей. Просмотр анкет продемонстрирован на рисунке 15. Если у пользователя есть предпочтения к поиску, тогда он может воспользоваться фильтром поиска. Например, пользователь ищет девушку из города Саратов в возрасте от восемнадцати до двадцати трёх. Тогда в результате выведутся анкеты, соответствующие требованиям.
 
Рисунок 15 - Просмотр анкет пользователей
Если попадётся понравившиеся анкеты, есть возможность перейти в профиль этого пользователя и узнать о нём подробнее, помимо этого можно нажать на кнопку «Like», после чего у данной пользователя, на анкете которого нажата эта кнопка, в разделе «Симпатии» выведется ваша анкета. Также по нажатию кнопки «Написать сообщение» происходит перенаправление в раздел «Сообщения», где создаётся чат с данным пользователем, в котором можно познакомиться, узнать друг о друге больше информации и договориться о встрече. Раздел «Сообщения» продемонстрирован на рисунке 16.
 
Рисунок 16 - Общение с другими пользователями











ЗАКЛЮЧЕНИЕ
В современном обществе, где люди сталкиваются с ограничениями по времени и расстоянию, сервисы знакомств становятся все более актуальными и востребованными. Они предоставляют возможность людям расширить свои круги общения, найти партнера для знакомства и создания отношений, не ограничиваясь только своим географическим положением или сферой деятельности. Сервисы знакомств облегчают процесс поиска подходящего партнера, предоставляя разнообразные возможности для выбора и общения.
В ходе разработки данного сервиса знакомств было проведено аналитическое исследование существующих решений на рынке. Были выявлены недостатки и ограничения, с которыми пользователи сталкиваются при использовании подобных сервисов. Также были определены требования к разрабатываемому сервису, чтобы обеспечить удобство и эффективность его использования.
Архитектура и функционал сервиса были разработаны с учетом современных технологий и требований. Были выбраны оптимальные инструменты и технологии, которые обеспечили гибкость и масштабируемость разработки. В ходе работы над сервисом знакомств "Duo" были использованы актуальные технологии, такие как Entity Framework (EF) Core и многоуровневая архитектура информационной системы. В заключении стоит подвести итоги проделанной работы:
1. Был проанализирован рынок сервисов знакомств;
2. Были определены требования к информационной системе;
3. Были разработаны архитектура и функционал сервиса;
4. Реализован базового функционала сервиса.
Цель, поставленная в начале работы, достигнута, задачи для её достижения
выполнены.



СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ
1	Организационная структура предприятия: виды и схемы [Электронный ресурс] // [сайт]. – URL: https://kontur.ru/articles/4197 (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
2	LovePlanet.ru [Электронный ресурс] // [Сайт]. – URL: https://ru.wikipedia.org/wiki/LovePlanet.ru (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
3	Теамо.ру [Электронный ресурс] // [Сайт]. – URL: https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%B0%D0%BC%D0%BE.%D1%80%D1%83 (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
4	Как создать организационную структуру [Электронный ресурс] // [Сайт]. – URL: https://asana.com/ru/resources/organizational-chart (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
5	Архитектура ИС, типы архитектур. Классификация ИС [Электронный ресурс] // [Сайт]. – URL: https://studopedia.ru/7_188991_arhitektura-is-tipi-arhitektur-klassifikatsiya-is.html (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
6	Монолитная архитектура [Электронный ресурс] // [Сайт]. – URL: https://procodings.ru/dev-ru/monolitnaya-arhitektura/  (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
7	Клиент-серверная архитектура в картинках [Электронный ресурс] // [Сайт]. – URL: https://habr.com/ru/articles/495698/  (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
8	Многоуровневая архитектура [Электронный ресурс] // [Сайт]. – URL: https://studwood.net/1892479/informatika/mnogourovnevaya_arhitektura (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
9	Микросервисная архитектура: что это, кому подойдёт, с чего начать [Электронный ресурс] // [Сайт]. – URL: https://cloud.yandex.ru/blog/posts/2022/03/microservice-architecture (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
10	Реляционные базы данных [Электронный ресурс] // [Сайт]. – URL: https://cloud.yandex.ru/docs/glossary/relational-databases (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
11	Уровни моделирования (проектирования) БД [Электронный ресурс] // [Сайт]. – URL: https://infopedia.su/1x61fe.html (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
12	Мокрозуб, В.Г. Представление графов и неориентированных гиперграфов с ограничениями в реляционной базе данных / В. Г. Мокрозуб, В. А. Немтинов, Д. А. Лагутин // Программные продукты и системы. – 2011. – № 4. – С. 91-96.
13	Сравнение современных СУБД [Электронный ресурс] // [Сайт]. – URL: https://drach.pro/blog/hi-tech/item/145-db-comparison (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
14	What is .NET? [Электронный ресурс] // [Сайт]. – URL: https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
15	Смит Дж. П. Entity Framework Core в действии Entity Framework Core в действии / пер. с англ. Д. А. Беликова. – М.: ДМК Пресс, 2022. – 690 с.: ил.
16	Создание базы данных с помощью Code First [Электронный ресурс] // [Сайт]. – URL: https://learn.microsoft.com/ru-ru/ef/ef6/modeling/code-first/workflows/new-database (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
17	База данных first [Электронный ресурс] // [Сайт]. – URL: https://learn.microsoft.com/ru-ru/ef/ef6/modeling/designer/workflows/database-first  (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.

18	Visual Studio [Электронный ресурс] // [Сайт]. – URL: https://visualstudio.microsoft.com/ru/ (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
19	Дэкетт, Д. HTML и CSS. Разработка и создание веб-сайтов / Джон Дэкетт. – Москва: Эксмо, 2014. – 480 с.
20	Маккоу, А. Веб-приложения на JavaScript / А. Маккоу – М.: издательство “Питер”, 2012. – 18 с.
21	Регистрация и создание пользователей в ASP.NET Identity [Электронный ресурс] // [Сайт]. – URL: https://metanit.com/sharp/mvc5/12.16.php (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
22	Авторизация пользователей в ASP.NET Identity [Электронный ресурс] // [Сайт]. – URL: https://metanit.com/sharp/mvc5/12.17.php (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
23	Введение в ASP.NET Core MVC [Электронный ресурс] // [Сайт]. – URL: https://metanit.com/sharp/aspnetmvc/1.1.php (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.
24	Модель представления [Электронный ресурс] // [Сайт]. – URL: https://metanit.com/sharp/aspnet5/8.2.php (дата обращения: 25.04.2023). – Загл. с экрана. – Яз. рус.











Приложение А
Создание базы данных и таблиц
CREATE DATABASE Krop;
CREATE TABLE Users (
  UserId INT PRIMARY KEY IDENTITY(1,1),
  Username VARCHAR(50) NOT NULL UNIQUE,
  Password VARCHAR(50) NOT NULL,
  FirstName VARCHAR(50) NOT NULL,
  LastName VARCHAR(50) NOT NULL,
  Age INT,
  Height FLOAT,
  Weight FLOAT,
  City varchar(50),
  PhotoUrl varchar(max),
  Zodiac varchar(25),
  InterestType varchar(25),
  InterestDescription varchar(255),
  Email varchar(50),
  Gender NVARCHAR(10)
);
CREATE TABLE Likes (
    LikeId INT PRIMARY KEY IDENTITY(1,1),
    SenderId INT,
    RecipientId int,
    CONSTRAINT FK_Likes1_Users FOREIGN KEY (SenderId) REFERENCES Users(UserId),
	CONSTRAINT FK_Likes2_Users FOREIGN KEY (RecipientId) REFERENCES Users(UserId)
);
CREATE TABLE Guests (
    GuestId INT PRIMARY KEY IDENTITY(1,1),
    SenderGId INT,
    RecipientGId int,
    CONSTRAINT FK_Guests1_Users FOREIGN KEY (SenderGId) REFERENCES Users(UserId),
	CONSTRAINT FK_Guests2_Users FOREIGN KEY (RecipientGId) REFERENCES Users(UserId)
);
CREATE TABLE Messages(
    MessageId INT PRIMARY KEY IDENTITY(1,1),
    SenderId INT,
    RecipientId int,
	Content nvarchar(max),
	Timestamp datetime,
    CONSTRAINT FK_Messages1_Users FOREIGN KEY (SenderId) REFERENCES Users(UserId),
	CONSTRAINT FK_Messages2_Users FOREIGN KEY (RecipientId) REFERENCES Users(UserId)
);











Приложение Б 
Классы моделей базы данных
public partial class User
{
    public int UserId { get; set; }

    public string Username { get; set; } = null!;

    public string Password { get; set; } = null!;

    public string FirstName { get; set; } = null!;

    public string LastName { get; set; } = null!;

    public int? Age { get; set; }

    public double? Height { get; set; }

    public double? Weight { get; set; }

    public string? Gender { get; set; }

    public string? City { get; set; }

    public string? PhotoUrl { get; set; }

    public string? Zodiac { get; set; }

    public string? InterestType { get; set; }

    public string? InterestDescription { get; set; }

    public string? Email { get; set; }

    public virtual ICollection<Like> LikeRecipients { get; set; } = new List<Like>();

    public virtual ICollection<Like> LikeSenders { get; set; } = new List<Like>();

    public virtual ICollection<Message> MessageRecipients { get; set; } = new List<Message>();

    public virtual ICollection<Message> MessageSenders { get; set; } = new List<Message>();
}
public partial class Message
{
    public int MessageId { get; set; }

    public int? SenderId { get; set; }

    public int? RecipientId { get; set; }

    public string? Content { get; set; }

    public DateTime? Timestamp { get; set; }

    public virtual User? Recipient { get; set; }

    public virtual User? Sender { get; set; }
}
public partial class Like
{
    public int LikeId { get; set; }

    public int? SenderId { get; set; }

    public int? RecipientId { get; set; }

    public virtual User? Recipient { get; set; }

    public virtual User? Sender { get; set; }
}
public partial class Guest
{
    public int GuestId { get; set; }

    public int? SenderId { get; set; }

    public int? RecipientId { get; set; }

    public virtual User? Recipient { get; set; }

    public virtual User? Sender { get; set; }
}

Приложение В
Код регистрации пользователя
[HttpPost]
        public async Task<IActionResult> Registration(string login, string email, string firstname, string lastname, string password, string password2)
        {
            if (password == password2 && login != null)
            {
                Entity.User player = new Entity.User()
                {
                    Username = login,
                    Email = email,
                    FirstName = firstname,
                    LastName = lastname,
                    Password = password
                };
                await Authenticate(login);
                BL.UserBL.Registrations(player);
                return RedirectToAction("Registration2", "Home");
            }
            return View();
        }
        public IActionResult Registration()
        {
            return View();
        }

















Приложение Г 
Код авторизации пользователя
[HttpPost]
        public async Task<IActionResult> Index(string login, string password)
        {
            Entity.User player = new Entity.User()
            {
                Username = login,
                Password = password
            };
            if (BL.UserBL.Autorisations(player) == true)
            {
                await Authenticate(login);
                return RedirectToAction("Profile", "Home");
            }
            return View();
        }
        private async Task Authenticate(string userName)
        {
            var claims = new List<Claim>
            {
                new Claim(ClaimsIdentity.DefaultNameClaimType, userName)
            };
            ClaimsIdentity id = new ClaimsIdentity(claims, "ApplicationCookie", ClaimsIdentity.DefaultNameClaimType, ClaimsIdentity.DefaultRoleClaimType);
            await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(id));
        }
public static bool Autorisations(Entity.User player)
        {
            var getPlayer = DAL.UserDAL.Get(player.Username);
            if (player.Password == getPlayer.Password)
            {
                return true;
            }
            else
            {
                return false;
            }
        }


Приложение Д
Использование модели данных в представлении
@model List<Entity.User>
@foreach (var user in Model)
{
            <div class="profile">
                <div class="profile-image">
                        <img src="@user.PhotoUrl" alt="Фото профиля" />
                </div>
                <div class="profile-details">
            <p>Имя: @user.FirstName Фамилия: @user.LastName</p>
            <p>Возраст: @user.Age</p>
            <p>Город: @user.City</p>
            <p>Знак зодиака: @user.Zodiac Пол: @user.Gender</p>
                </div>
            </div>
            }










